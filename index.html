<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quiz Interface</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap" rel="stylesheet" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Initialize TailwindCSS
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ["Open Sans", "sans-serif"],
                    },
                },
            },
        };
    </script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f9fafb;
            /* Light theme background */
        }

        .question-card {
            width: 600px;
            padding: 2rem;
            background: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .option {
            display: block;
            margin: 0.5rem 0;
        }

        .option input[type="radio"] {
            margin-right: 1rem;
        }

        .submit-result {
            background-color: #ffffff;
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #eaeaea;
            text-align: center;
        }

        .back-button {
            display: block;
            margin-top: 1rem;
        }

        .jump-to-result {
            display: block;
            margin-top: 1rem;
            text-align: center;
        }

        .card {
            background-color: #fef3c7;
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #fde68a;
        }
    </style>
</head>

<body class="text-gray-900 font-sans">
    <div id="app" class="question-card">
        <div class="question" v-if="currentQuestion">
            <div class="question-number mb-4 text-lg font-bold">
                第 {{ currentQuestion.question_number }} 題
            </div>
            <div class="question-text mb-4 text-xl font-bold">{{ currentQuestion.question }}</div>
            <form @submit.prevent="submitAnswer">
                <div class="options text-lg font-bold">
                    <label class="option" v-for="(option, key) in currentQuestion.options" :key="key">
                        <input class="mr-2 w-4 h-4" type="checkbox" :value="key" v-model="selectedOptions" /> {{ key }}:
                        {{ option }}
                    </label>


                </div>
                <div class="flex row pb-2 space-x-4">
                    <button type="button" @click="goBack"
                        class="back-button px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 text-lg font-bold">
                        上一題
                    </button>
                    <button type="submit"
                        class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-lg font-bold">
                        下一題
                    </button>
                    <button type="button" @click="jumpToResult"
                        class="jump-to-result px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 text-lg font-bold">
                        直接繳交
                    </button>
                </div>
            </form>
            <div class="submit-result" v-if="showResult">
                <p v-if="isCorrect" class="text-green-600 text-lg font-bold">正確!</p>
                <p v-else class="text-red-600 text-lg font-bold">
                    錯誤，正確答案應為 {{ currentQuestion.correct_answer }}.
                </p>
            </div>
        </div>
        <div class="pt-60 result" v-else>

            <div class="result-text mb-4 text-green-600 text-lg font-bold">
                測驗結束!
            </div>
            <div class="score text-lg font-bold">
                你的答對率: {{ score }}/{{ questions.length }} 題
            </div>
            <div class="wrong-answers " v-if="wrongAnswers.length > 0">
                <h3 class="text-lg font-semibold mb-2">以下是你答錯的題目:</h3>
                <div v-for="wrongAnswer in wrongAnswers" :key="wrongAnswer.question_number" class="card">
                    <div>
                        第 {{ wrongAnswer.question_number }} 題 : {{ wrongAnswer.question
                        }}
                    </div>
                    <div>你的答案 : {{ wrongAnswer.selected_answer }}</div>
                    <div>正確答案 : {{ wrongAnswer.correct_answer }}</div>
                </div>
            </div>
            <button @click="restartExam"
                class="mt-4 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 text-lg font-bold">
                重新開始測驗
            </button>
        </div>
    </div>

    <script src="https://unpkg.com/vue@3"></script>
    <script>
        const { createApp, ref } = Vue;
        const selectedOptions = ref([]);

        createApp({
            setup() {
                var default_questions = ref([
                    {
                        "question_number": 1,
                        "question": "Solidity智能合約的第一行是版本宣告，請問下列那些是正確的寫法？ (多選題)",
                        "options": {
                            "A": "pragma solidity 0.5.0;",
                            "B": "Pragma solidity 0.4.20;",
                            "C": "pragma solidity ^0.4.22;",
                            "D": "Solidity ^0.4.21;"
                        },
                        "correct_answer": ["A", "C"]
                    },
                    {
                        "question_number": 2,
                        "question": "有一solidity程式碼片段如右，struct Member{ string mbrName; uint mbrAge; } mapping(uint => Member) public mbrHash; ，針對此一程式片段請問下列那些選項是正確的？[^1^][1] (多選題)",
                        "options": {
                            "A": "mbrHash如同是資料庫中的一張資料表",
                            "B": "若是 uint id = 3; string name = \"John\"; uint age = 24; 則可以建構 mbrHash[id] = Member({mbrName:name, mbrAge:age});",
                            "C": "在solidity智能合約中，為了模擬一資料表，通常結構型別會與映射型別一起搭配使用",
                            "D": "mbrHash是映射型別變數"
                        },
                        "correct_answer": ["A", "B", "C", "D"]
                    },
                    {
                        "question_number": 3,
                        "question": "下列有關陣列(Array)的敘述，何者有誤?",
                        "options": {
                            "A": "陣列可以在宣告時指定長度，也可以動態可變長度",
                            "B": "對於存儲在 memory 的陣列來說，如果它被宣告 public，則其元素不能是映射類型",
                            "C": "對存儲在 storage 的陣列來說，其元素類型可以是任意的",
                            "D": "創建一個存儲在 memory 上的陣列，該陣列可以通過 成員.length 的值來修改陣列的大小。",

                        },
                        "correct_answer": ["D"]
                    },
                    {
                        "question_number": 4,
                        "question": "以下有關Slidity語言的描述，那些是正確的？(多選題)",
                        "options": {
                            "A": "EVM (Ethereum Virtual Machine)中文為「以太坊虛擬機」，是智能合約的執行環境",
                            "B": "Solidity 是動態型語言，編譯後可以在 EVM 上執行",
                            "C": "Solidity 語言仍處於持續開發階段，變動非常的頻繁",
                            "D": " Solidity是一種合約式導向的程式語言，可用來撰寫智能合約"
                        },
                        "correct_answer": ["A","C", "D"]
                    },
                    {
                        "question_number": 5,
                        "question": "有一事件 event MyEvent(address indexed _from, uint myInt)，請問上述 indexed 是表示甚麼？",
                        "options": {
                            "A": "表示_from是索引欄位",
                            "B": "表示_from 是數值型態",
                            "C": "表示_from是特殊欄位",
                            "D": "表示_from是位址型態"
                        },
                        "correct_answer": ["A"]
                    },
                    {
                        "question_number": 6,
                        "question": "參見檔案：Herent.sol，為何在 constructor(string memory _msg1)中，必須為參數_msg1加上memory？ https://cdn.discordapp.com/attachments/672820483862953994/1252302868564807822/0e7680e9cd50b76677e3b4f5c118531c.png?ex=6671b96e&is=667067ee&hm=1c7129bf513f2f90916b9e04bf0986d097f5d65c1cf8793b565e7b12520abc9e&",
                        "options": {
                            "A": "因為_msg1是建構子的輸入參數，因只是短暫使用，故宣告為memory",
                            "B": "因為_msg1是特殊型別，故必須宣告為memory",
                            "C": "因為_msg1是合約中的重要參數，故必須宣告為memory",
                            "D": "因為_msg1是用來設定狀態變數，故必須宣告為memory"
                        },
                        "correct_answer": ["A"]
                    },
                    {
                        "question_number": 7,
                        "question": "有關Solidity語言的描述，以下那些是正確的？(多選題)",
                        "options": {
                            "A": "可以在 EVM 上執行",
                            "B": "是靜態型語言",
                            "C": "是一種合約式導向的程式語言",
                            "D": "可以用來撰寫比特幣智能合約"

                        },
                        "correct_answer": ["A", "B", "C",]
                    },
                    {
                        "question_number": 8,
                        "question": "首次數位貨幣公開募資，其英文簡稱為何？",
                        "options": {
                            "A": "IOI",
                            "B": "IEO",
                            "C": "ICE",
                            "D": "ICO"
                        },
                        "correct_answer": ["D"]
                    },
                    {
                        "question_number": 9,
                        "question": "以太坊區塊鏈因具有智能合約之功能，所以它有兩種帳戶，請問是哪兩種帳戶？(多選題)",
                        "options": {
                            "A": "外部帳戶",
                            "B": "合約帳戶",
                            "C": "內部帳戶",
                            "D": "混合帳戶"
                        },
                        "correct_answer": ["A", "B"]
                    },
                    {
                        "question_number": 10,
                        "question": "在一智能合約中，假若 a 是一變數，則 delete a; 是代表甚麼意義？",
                        "options": {
                            "A": "清除記憶體 a",
                            "B": "刪除記憶體 a 內容為空白",
                            "C": "刪除記憶體 a 內容為空白",
                            "D": "還原記憶體 a 內容為0"
                        },
                        "correct_answer": ["D"]
                    },
                    {
                        "question_number": 11,
                        "question": "在Solidity語言中，有關定長位元組陣列，下列哪些是合法的型態？(多選題)",
                        "options": {
                            "A": "在Solidity語言中，有關定長位元組陣列，下列哪些是合法的型態？(多選題)",
                            "B": "在Solidity語言中，有關定長位元組陣列，下列哪些是合法的型態？(多選題)",
                            "C": "byte",
                            "D": "bytes64"
                        },
                        "correct_answer": ["A", "B"]
                    },
                    {
                        "question_number": 12,
                        "question": "下列有關映射型別(mapping)的敘述，何者有誤？",
                        "options": {
                            "A": "映射型別有 length 成員，也提供迭代（iterable）",
                            "B": "映射型別有 length 成員，也提供迭代（iterable）",
                            "C": "它是一種「主鍵－資料」形式的資料結構",
                            "D": "主鍵是唯一值，透過使用該唯一值便能夠取得對映的資料內容",
                        },
                        "correct_answer": ["A"]
                    },
                    {
                        "question_number": 13,
                        "question": "下列有關Solidity中各種函數之可見性，哪些是正確的？(多選題)",
                        "options": {
                            "A": " private - 僅在當前合約內才可訪問",
                            "B": "private - 僅在當前合約內才可訪問",
                            "C": "private - 僅在當前合約內才可訪問",
                            "D": "internal - 僅在當前合約及所繼承的合約內，才可訪問"
                        },
                        "correct_answer": ["A", "B", "C", "D"]
                    },
                    {
                        "question_number": 14,
                        "question": "下列有關陣列型別的敘述，何者有誤？",
                        "options": {
                            "A": " 對於 memory 陣列來說，陣列元素可以是 mapping 型別",
                            "B": "對於 memory 陣列來說，陣列元素可以是 mapping 型別",
                            "C": "對於 memory 陣列來說，陣列元素可以是 mapping 型別",
                            "D": "對於 memory 陣列來說，陣列元素可以是 mapping 型別",

                        },
                        "correct_answer": ["A"]
                    },
                    {
                        "question_number": 15,
                        "question": "現有一指令 uint128[] storage x ; 請問對於此指令之變數 x 的描述，下列哪些是正確的？(多選題)",
                        "options": {
                            "A": "x是元素個數不定的陣列變數",
                            "B": "x是元素個數為128的陣列變數",
                            "C": "x是元素個數為128的陣列變數",
                            "D": "可以用指令 x.push(77)；將 整數 77 儲存至陣列 x 的第0個位置中",

                        },
                        "correct_answer": ["A"]
                    }
                    ,
                    {
                        "question_number": 16,
                        "question": "有一Solidity智能合約如下，請問有關此合約，下列選項是正確的？ https://cdn.discordapp.com/attachments/672820483862953994/1252306112246710323/d25178caee5119830d16e246fc29de95.png?ex=6671bc73&is=66706af3&hm=3829e041bf36550e0e5a69ab606a326cf76ebdfa8768969981fd2c53cbeec00e&",
                        "options": {
                            "A": "第3列 是合約內部的狀態變數宣告",
                            "B": "第四列 是建構子宣告定義",
                            "C": "第四列 是建構子宣告定義",
                            "D": "第四列 是建構子宣告定義"
                        },
                        "correct_answer": ["A", "B", "C", "D"]
                    },
                    {
                        "question_number": 17,
                        "question": "以太坊之外部帳戶的英文簡稱為何？",
                        "options": {
                            "A": "DOE",
                            "B": "DOA",
                            "C": "EOA",
                            "D": "EOD"
                        },
                        "correct_answer": ["C"]
                    }
                    ,
                    {
                        "question_number": 18,
                        "question": "下列是有關Solidity函數型態的敘述，哪些是正確的？(多選題)",
                        "options": {
                            "A": "函數型態預設是 external，因此 external 可以省去",
                            "B": "有兩個方式可以訪問函數，一種是直接用函數名，一種是 this.函數名，前者用於合約內部函數，後者用於合約外部函數",
                            "C": "函數型態有兩類：內部(internal)函數和外部(external)函數",
                            "D": "內部(internal)函數：此種函數只能在當前合約內被呼叫"
                        },
                        "correct_answer": ["B"]
                    }
                    ,
                    {
                        "question_number": 19,
                        "question": "在以太坊智能合約中，下列哪兩個函數最常被用來進行虛擬貨幣的交易？(多選題)",
                        "options": {
                            "A": "send()函?",
                            "B": "transmission()函?",
                            "C": "receive()函?",
                            "D": "transfer()函?"
                        },
                        "correct_answer": ["A", "D"]
                    }
                    ,

                    {
                        "question_number": 20,
                        "question": "參見檔案：Herent.sol，請問當執行摧毀合約指令 selfdestruct(owner);時，若智能合約B中尚有虛擬貨幣餘額，請問這些餘額會如何處理？ https://cdn.discordapp.com/attachments/672820483862953994/1252306781854761070/e8561229a3c4539b1564c33cff8a7521.png?ex=6671bd13&is=66706b93&hm=0d77464906dae6a4587b8373f632d431658befa8b365afe3099436f357557907&",
                        "options": {
                            "A": "餘額自我消失",
                            "B": "餘額由智能合約擁有者與以太坊官方平分。",
                            "C": "餘額歸給以太坊官方",
                            "D": "餘額歸給智能合約擁有者",
                        },
                        "correct_answer": ["D"]
                    }
                    , {
                        "question_number": 21,
                        "question": "以太坊之合約位址(CA)及外部帳戶位址(EOA)的長度皆為幾個Bytes？",
                        "options": {
                            "A": "30",
                            "B": "10",
                            "C": "20",
                            "D": "40"
                        },
                        "correct_answer": ["C"]
                    }
                    , {
                        "question_number": 22,
                        "question": "參見檔案：Herent.sol，為了完成owner虛擬貨幣的轉移，owner必須宣告甚麼？ https://cdn.discordapp.com/attachments/672820483862953994/1252307106103820329/6dc0eb700818f088134fce0b3242608b.png?ex=6671bd60&is=66706be0&hm=83591588fb476c4f2315acbbc002e188eb1504263fe615d01bd80eab205e9ba7&",
                        "options": {
                            "A": "public",
                            "B": "external",
                            "C": "address",
                            "D": "payable"
                        },
                        "correct_answer": ["D"]
                    },
                    {
                        "question_number": 23,
                        "question": "下列有關於儲存地點的敘述，何者有誤？",
                        "options": {
                            "A": "輸入函數的參數與回傳值是以 memory 的方式儲存",
                            "B": "合約的狀態變數是儲存在 storage",
                            "C": " 合約的狀態變數是儲存在 storage",
                            "D": " 為了節省 gas，通常會盡量將區域變數宣告為 memory"
                        },
                        "correct_answer": ["C"]
                    }, {
                        "question_number": 24,
                        "question": "以下有關Slidity語言的描述，那些是正確的？(多選題)",
                        "options": {
                            "A": "Solidity 中的虛擬貨幣單位通常採用ether",
                            "B": "Solidity 中可用中文。",
                            "C": "Solidity 中可用浮點數",
                            "D": "Solidity 中的時間是從1970年1月1日開始起算，並以秒為單位",
                        },
                        "correct_answer": ["A", "D"]
                    }
                    , {
                        "question_number": 25,
                        "question": "下列有關Solidity內建全域變數的敘述，何者有誤?",
                        "options": {
                            "A": "tx.gasprice(uint)： 表示交易的 gas 的單價",
                            "B": "now(uint)：表示當前區塊的Unix時間戳記",
                            "C": "block.timestamp(uint)：表示當前區塊的 Unix 時間戳記",
                            "D": "block.gaslimit(uint)：表示當前區塊鏈礦工的位址"
                        },
                        "correct_answer": ["D"]
                    }
                    , {
                        "question_number": 26,
                        "question": "有一solidity程式碼片段如右， struct Member{ string mbrName; uint mbrAge; }，針對此一程式片段請問下列那些選項是正確的？(多選題)",
                        "options": {
                            "A": "這結構型別語法有錯誤，應將{ }改為 [ ]",
                            "B": "這是一結構自定型別",
                            "C": "這個結構型別稱為Member",
                            "D": "這個結構型別有兩個欄位(成員)",
                        },
                        "correct_answer": ["B", "C", "D"]
                    }
                    , {
                        "question_number": 27,
                        "question": "參見檔案：Herent.sol，其中 onlyOwner( )稱為？https://cdn.discordapp.com/attachments/672820483862953994/1252308617487585391/176dd67da90d454e8e60a9656a5c7bd2.png?ex=6671bec9&is=66706d49&hm=5b80b996c3be763fd41f4edfb280458a149bb83459e86af20acbf2b08d0629d5&",
                        "options": {
                            "A": "miner.start(2) 表示開始挖礦，並設執行緒為2",
                            "B": "eth.mining 用來確認是否有在挖礦",
                            "C": "miner.sleep() 表示暫停挖礦",
                            "D": "miner.stop() 表示停止挖礦",
                        },
                        "correct_answer": ["C"]
                    }
                    , {
                        "question_number": 28,
                        "question": "在Solidity語言中，uint型態與下列何者是一樣的型態？",
                        "options": {
                            "A": "uint256",
                            "B": "uint512",
                            "C": "int256",
                            "D": "uint128"
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 29,
                        "question": "下列有關智能合約的描述，那些是正確的？(多選題)",
                        "options": {
                            "A": "constant與view意義是一樣的，現已建議constant不要用",
                            "B": "constant與view意義是一樣的，現已建議constant不要用",
                            "C": "constant與view意義是一樣的，現已建議constant不要用",
                            "D": "若函數宣告為payable時，表示可透過此函數，將加密貨幣傳輸給智能合約",
                        },
                        "correct_answer": ["A", "B", "C", "D"]
                    }
                    , {
                        "question_number": 30,
                        "question": "以太坊之外部帳戶的位址長度為幾位？(以16進制表示)",
                        "options": {
                            "A": "64",
                            "B": "40",
                            "C": "60",
                            "D": "32",
                        },
                        "correct_answer": ["B"]
                    }
                    , {
                        "question_number": 31,
                        "question": "下列有關Solidity的敘述何者有誤？",
                        "options": {
                            "A": "註解之撰寫無法提高程式碼的維護性與閱讀性",
                            "B": "狀態變數類似於傳統物件導向程式語言的物件變數",
                            "C": "支援繼承、函數庫化，並允許使用者自訂複雜的資料型別",
                            "D": "函數宣告就是程式設計師實作智能合約處理邏輯的地方",
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 32,
                        "question": "Ganache(舊名稱TestRPC)提供快速結塊、快速確認區塊功能之(純記憶體)私有測試鏈網絡，請問它預設提供10測試帳戶，每一帳戶有多少ETH？",
                        "options": {
                            "A": "10",
                            "B": "500",
                            "C": "200",
                            "D": "100"
                        },
                        "correct_answer": ["D"]
                    }
                    , {
                        "question_number": 33,
                        "question": "有關智能合約和一般程式的差異，以下那些是正確的說法？(多選題)",
                        "options": {
                            "A": "智能合約部署之後不能修改",
                            "B": "智能合約寫入資料需要成本",
                            "C": "智能合約需要有固定主機進行執行工作",
                            "D": ". 智能合約整合金流容易"
                        },
                        "correct_answer": ["A", "B", "D"]
                    }
                    , {
                        "question_number": 34,
                        "question": "下列哪些屬於參照型別(reference type)?(多選題)",
                        "options": {
                            "A": "布林型別(boolean)",
                            "B": "映射型別(mapping)",
                            "C": "整數型別(integer)",
                            "D": "結構型別(struct)"
                        },
                        "correct_answer": ["B", "D"]
                    }, {
                        "question_number": 35,
                        "question": "下列有關布林型別(Boolean)的敘述，何者有誤?",
                        "options": {
                            "A": "在 || 運算中，若第一個運算元的值為true，接下來的運算元就不必運算了，直接可回傳true",
                            "B": "!= 表示邏輯NOT ; && 表示邏輯AND ; || 表示邏輯OR ; ! 表示邏輯不等於",
                            "C": "在 && 運算中，兩者必須為 true，結果才會為 true，否則皆為 false",
                            "D": "Solidity不會自動將非布林型別的變數轉換成布林型別，因此if (1) { ... }在 Solidity中是不合法的"
                        },
                        "correct_answer": ["B"]
                    }
                    , {
                        "question_number": 36,
                        "question": "下列關於資料儲存位置(Data Location)的敘述，何者有誤?",
                        "options": {
                            "A": "函數參數(包括返回的參數)，其預設存儲位置是memory",
                            "B": "若資料屬性是memory，則資料不是永久存在的；若資料屬性是storage，則資料永久存儲在區塊鏈中",
                            "C": "區域複雜類型變數( local variables)和狀態變數(state variables)，其預設存儲位置是 memory",
                            "D": "所有的複雜類型，例如陣列和結構體，都有一個額外屬性：資料存儲位置，即 memory 或 storage"
                        },
                        "correct_answer": ["C"]
                    }
                    , {
                        "question_number": 37,
                        "question": "下列關於位址(Address)類型的敘述，何者有誤?",
                        "options": {
                            "A": "為確保乙太幣轉帳的安全，一定要檢查.send 的返回值，或者改用. transfer",
                            "B": "位址類型是一個數值類型，位址佔用 20 位元組",
                            "C": "getCode()：如果參數是合約位址，則返回'0x'；如果參數是外部帳號位址，則返回對應的位元組程式碼",
                            "D": "如果執行失敗，.transfer 會拋出異常並終止代碼，而＜address> .send 則是返回 false，但代碼繼續執行"
                        },
                        "correct_answer": ["C"]
                    }
                    , {
                        "question_number": 38,
                        "question": "Solidity之陣列可以宣告成 type [M]，其中 type 是陣列元素的型別，而[M]是表示陣列元素的什麼？",
                        "options": {
                            "A": "個數",
                            "B": "寬度",
                            "C": "複雜度",
                            "D": "多元型別"
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 39,
                        "question": "以太坊之合約帳戶的位址長度為幾位？(以16進制表示)",
                        "options": {
                            "A": "40",
                            "B": "64",
                            "C": "32",
                            "D": "60"
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 40,
                        "question": "下列哪些屬於數值型別(value type)?(多選題)",
                        "options": {
                            "A": "列舉型別(enum type)",
                            "B": "結構型別(struct)",
                            "C": "整數型別(integer)",
                            "D": "布林型別(boolean)"
                        },
                        "correct_answer": ["A","C" , "D"]
                    }
                    , {
                        "question_number": 41,
                        "question": "有關智能合約的事件描述，下列哪些是正確的？(多選題)",
                        "options": {
                            "A": "使用Event方式永久儲存資訊需要較高的gas成本",
                            "B": "Event必須搭配emit才可以被呼叫使用",
                            "C": "可以將交易明細的執行結果，透過Event方式永久寫入區塊鏈中",
                            "D": "事件是一種在Ethereum中進行紀錄的機制"
                        },
                        "correct_answer": ["B" ,"C", "D"]
                    }
                    , {
                        "question_number": 42,
                        "question": "現有一指令 uint128[] memory x = new uint128[](5); 請問對於此指令之變數 x 的描述，下列哪些是正確的？(多選題)",
                        "options": {
                            "A": "x是元素個數為5的陣列變數",
                            "B": "可以用指令 x[0] = 77；將 整數 77 儲存至陣列 x 的第0個位置中",
                            "C": "可以用指令 x[0] = 77；將 整數 77 儲存至陣列 x 的第0個位置中",
                            "D": "x的陣列元素儲存資料不需要挖礦"
                        },
                        "correct_answer": ["A","B", "D"]
                    }
                    , {
                        "question_number": 43,
                        "question": "為了讓等號兩邊的型別一致，編譯器會協助進行自動型別轉換，請問這是哪一種型別轉換？",
                        "options": {
                            "A": "動態轉換",
                            "B": "隱式轉換",
                            "C": "適性轉換",
                            "D": "顯示轉換"
                        },
                        "correct_answer": ["B"]
                    }
                    , {
                        "question_number": 44,
                        "question": "在Solidity語言中，有關整數型態，下列哪些是合法的？(多選題)",
                        "options": {
                            "A": "int128",
                            "B": "int256",
                            "C": "uint256",
                            "D": "int512"
                        },
                        "correct_answer": ["A","B", "C"]
                    }
                    , {
                        "question_number": 45,
                        "question": "參見檔案：Herent.sol，請問當呼叫close( )時，必須通過onlyOwner( )所訂定之條件，若沒有滿足，則會產生甚麼結果？https://cdn.discordapp.com/attachments/672820483862953994/1252311720081494046/56decfa465fb1eca706837044528dc11.png?ex=6671c1ac&is=6670702c&hm=23b76143951095c6c34706fedc97852e1a3b23b2d175d9825d116ac857d1fe6f&",
                        "options": {
                            "A": "畫面沒有任何回應",
                            "B": "畫面輸出'who create contract can call this function.'",
                            "C": "程式執行中止",
                            "D": "程式不受任何影響"
                        },
                        "correct_answer": ["B"]
                    }
                    , {
                        "question_number": 46,
                        "question": "下列有關Solidity的敘述，何者'有誤'？",
                        "options": {
                            "A": "事件(Event)是乙太坊虛擬機器(EVM)日誌基礎設施，他提供的一個便利介面，用於獲取當前發生的事件",
                            "B": "狀態變數(State Variable)和其他語言的成員變數很相似，狀態變數會被永久存儲在合約的存儲空間(storage)裡",
                            "C": "結構類型(Struct Type)是一組使用者自定的變數組合在一起形成的類型",
                            "D": "單行註解使用“#”，多行註解使用'/ … /'"
                        },
                        "correct_answer": ["D"]
                    }
                    , {
                        "question_number": 47,
                        "question": "下列何者不是Solidity的貨幣單位(Ether Unit)?",
                        "options": {
                            "A": "finney",
                            "B": "minute",
                            "C": "wei",
                            "D": "ether(ETH)"
                        },
                        "correct_answer": ["B"]
                    }
                    , {
                        "question_number": 48,
                        "question": "以太坊智能合約中，那些型別是屬於數值型別？(多選題)",
                        "options": {
                            "A": "布林型別",
                            "B": "位址型別",
                            "C": "列舉型別",
                            "D": "byte陣列型別"
                        },
                        "correct_answer": ["B", "C", "D"]
                    }
                    , {
                        "question_number": 49,
                        "question": "下列有關智能合約的函數之可視度，那些描述是正確的？(多選題)",
                        "options": {
                            "A": "宣告為public的函數可經由內部呼叫或經由交易方式呼叫",
                            "B": "宣告為private的函數只能被自己合約呼叫，即便是繼承此合約的其他合約也不能呼叫",
                            "C": "宣告為external的函數可被其他智能合約呼叫或經由交易方式呼叫",
                            "D": "宣告為internal的函數只能被自己合約呼叫或繼承此合約的其他合約呼叫"
                        },
                        "correct_answer": ["A", "B", "C", "D"]
                    }
                    , {
                        "question_number": 50,
                        "question": "請問內建函數 revert() 具有甚麼作用？",
                        "options": {
                            "A": "表示放棄執行，並紀錄狀態",
                            "B": "表示繼續執行，並還原狀態",
                            "C": "表示放棄執行，並還原狀態",
                            "D": "表示繼續執行，並保留狀態"
                        },
                        "correct_answer": ["C"]
                    }
                    , {
                        "question_number": 51,
                        "question": "Solidity的函數之可見性修飾詞包括有哪些？(多選題)",
                        "options": {
                            "A": "external",
                            "B": "public",
                            "C": "private",
                            "D": "internal"
                        },
                        "correct_answer": ["A","B","C","D"]
                    }
                    , {
                        "question_number": 52,
                        "question": "為了能夠對函數及變數做適當的存取限制，可透過設定可視角度（visibilities）來控制，下列有關可視角度(visibilities)的敘述，何者'有誤'？",
                        "options": {
                            "A": "共有四種可視角度，分別是 external、public、internal 與 private",
                            "B": "狀態變數之可視角度的宣告必須置於型別宣告後，預設的可視角度為 external ，且不可設定為internal",
                            "C": "可視角度若用在函數宣告時，必須置於函數的傳入參數與回傳參數之間，預設的可視角度是 public",
                            "D": "internal"
                        },
                        "correct_answer": ["B"]
                    }
                    , {
                        "question_number": 53,
                        "question": "下列關於Solidity錯誤處理函數、數學及加密功能函數，哪些敘述是正確?(多選題)",
                        "options": {
                            "A": "require(bool condition)：用於判斷輸入或外部元件的錯誤，當 condition 為假時，會拋出異常",
                            "B": "revert()：終止執行，並將改變的狀態還原",
                            "C": "keccak256( ... ) returns (bytes32)：使用 keccak-256 計算 hash 值",
                            "D": "internal"
                        },
                        "correct_answer": ["A","B","C"]
                    }
                    , {
                        "question_number": 54,
                        "question": "有關string 及bytes 兩型別的描述，以下那些是正確的(多選題)",
                        "options": {
                            "A": "bytes 型別相當於 byte[ ] 陣列型別",
                            "B": "bytes 型別相當於 byte[ ] 陣列型別",
                            "C": "目前string已可以直接透過length成員，取得string的長度",
                            "D": "這兩型別是屬於非固定長度的特殊陣列型別"
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 55,
                        "question": "下列關於位址(Address)類型的敘述，何者'有誤'?",
                        "options": {
                            "A": "如果執行失敗，.transfer 會拋出異常並終止代碼，而＜address> .send 則是返回 false，但代碼繼續執行",
                            "B": "位址類型是一個數值類型，位址佔用 20 位元組",
                            "C": "getCode()：如果參數是合約位址，則返回'0x'如果參數是外部帳號位址，則返回對應的位元組程式碼",
                            "D": "為確保乙太幣轉帳的安全，一定要檢查.send 的返回值，或者改用. transfer"
                        },
                        "correct_answer": ["C"]
                    }
                    , {
                        "question_number": 56,
                        "question": "在使用Solidity語言開發以太坊智能合約中，請問下列哪些是智能合約的可能組成？(多選題)",
                        "options": {
                            "A": "引用其他合約",
                            "B": "編譯器版本宣告",
                            "C": "事件",
                            "D": "函數宣告"
                        },
                        "correct_answer": ["A","B","C","D"]
                    }
                    , {
                        "question_number": 57,
                        "question": "在智能合約中，請問內建變數 msg.value 表示甚麼？",
                        "options": {
                            "A": "當前訊息所傳輸的當量",
                            "B": "當前訊息所傳輸的數值",
                            "C": "當前訊息所傳輸的gas",
                            "D": "當前訊息所傳輸的加密貨幣數量"
                        },
                        "correct_answer": ["D"]
                    }
                    , {
                        "question_number": 58,
                        "question": "有關以太坊區塊鏈之合約帳戶的描述，以下那些是正確的？(多選題)",
                        "options": {
                            "A": "合約帳戶擁有公鑰及私鑰",
                            "B": "合約帳戶之原文為Contract Account，簡稱CA",
                            "C": "每個智能合約在部署後，就會產一個對應的合約帳戶",
                            "D": "合約帳戶可用以收取其他帳戶轉來的以太幣"
                        },
                        "correct_answer": ["B","C","D"]
                    }
                    , {
                        "question_number": 59,
                        "question": "有關Solidity之陣列型別，下列那些是正確的描述？",
                        "options": {
                            "A": "對於一個memory陣列而言，其元素型別可以是除了mapping型別之外的任意型別",
                            "B": "對於一個storage陣列而言，其元素型別可以是任意型別",
                            "C": "陣列儲存空間大小可以在編譯時決定",
                            "D": "陣列儲存空間大小不可以在執行階段動態時決定"
                        },
                        "correct_answer": ["A","B","C"]
                    }
                    , {
                        "question_number": 60,
                        "question": "下列是有關Solidity函數型態的敘述，何者'有誤'？",
                        "options": {
                            "A": "可以在函數呼叫中，返回一個函數",
                            "B": "不可將一個函數當作參數進行傳遞",
                            "C": "函數的回傳值可為一個以上的值",
                            "D": "可將一個函數賦值給一個函數類型的變數"
                        },
                        "correct_answer": ["B"]
                    }
                    , {
                        "question_number": 61,
                        "question": "以太坊之外部帳戶的私鑰長度為幾位？(以16進制表示)",
                        "options": {
                            "A": "40",
                            "B": "32",
                            "C": "60",
                            "D": "64"
                        },
                        "correct_answer": ["D"]
                    }
                    , {
                        "question_number": 62,
                        "question": "對於一個 storage 陣列而言，請問其元素儲存資料時，是否需要進行挖礦工作",
                        "options": {
                            "A": "需要挖礦",
                            "B": "不需要挖礦",
                            "C": "Solidity沒有明確規定",
                            "D": "視當時的GAS多寡，才決定是否挖礦"
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 63,
                        "question": "用 truffle 來開發Dapp有其方便性及優勢，請問以下有關 truffle 的相關敘述，那些是正確的？(多選題)",
                        "options": {
                            "A": "truffle 框架需預先訂製，花費不斐",
                            "B": "利用truffle部署智能合約時，必須先調整truffle-config.js配置檔",
                            "C": "truffle可以一併完成智能合約編譯、部署、及Dapp的測試",
                            "D": "可藉由 truffle unbox 安裝特定的某一DApp框架"
                        },
                        "correct_answer": ["B","C","D"]
                    }
                    , {
                        "question_number": 64,
                        "question": "下列有關整數型別(interger)的敘述，何者'有誤'?",
                        "options": {
                            "A": "對有號整數的負數進行右移運算時，等同於乘法運算",
                            "B": "uint表示無號整數，其中 M 為位元長度，範圍必須落在 0 < M <= 256，同時 M % 8 之餘數運算必須為 0",
                            "C": "Solidity 的整數型別分為有號數與無號數兩種，並且可根據能表達的數字大小，訂定不同資料長度",
                            "D": "a++ 表示將 a 的資料值當成該運算式之值進行計算後，才執行加 1 的動作；++a表示先執行加 1 的動作，再將結果當成該運算式之值進行計算"
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 65,
                        "question": "在本課程最後介紹三個DApp範例，其中第一、二範例皆實作於Ganache區塊鏈上，並使用其內建的帳戶錢包，請問下列那些敘述是正確的？(多選題)",
                        "options": {
                            "A": "預設使用Ganache的第一位帳戶當作部屬合約的人",
                            "B": "必須將Metamask錢包開關Disable",
                            "C": "TestRPC是Ganache的舊名稱",
                            "D": "Ganache區塊鏈是屬於記憶體區塊鏈"
                        },
                        "correct_answer": ["C","D"]
                    }
                    , {
                        "question_number": 66,
                        "question": "modifier onlyOwner{ require(msg.sender==owner, 'error'); _;}}，請問這個函數修飾子具有甚麼作用？",
                        "options": {
                            "A": "過濾條件作用",
                            "B": "控制作用",
                            "C": "提升效能作用",
                            "D": "美化作用"
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 67,
                        "question": "有一事件 event MyEvent(address indexed _from, uint myInt)，請問上述 indexed 是表示甚麼？",
                        "options": {
                            "A": "表示_from是索引欄位",
                            "B": "表示_from 是數值型態",
                            "C": "表示_from是位址型態",
                            "D": "表示_from是特殊欄位"
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 68,
                        "question": "下列關於資料儲存位置(Data Location)的敘述，何者'有誤'?",
                        "options": {
                            "A": "區域複雜類型變數( local variables)和狀態變數(state variables)，其預設存儲位置是 memory",
                            "B": "所有的複雜類型，例如陣列和結構體，都有一個額外屬性：資料存儲位置，即 memory 或 storage",
                            "C": "函數參數(包括返回的參數)，其預設存儲位置是memory",
                            "D": "若資料屬性是memory，則資料不是永久存在的；若資料屬性是storage，則資料永久存儲在區塊鏈中"
                        },
                        "correct_answer": ["A"]
                    }

                    , {
                        "question_number": 69,
                        "question": "Ganache(舊名稱TestRPC)提供快速結塊、快速確認區塊功能之(純記憶體)私有測試鏈網絡，請問它預設提供10測試帳戶，每一帳戶有多少ETH？",
                        "options": {
                            "A": "100",
                            "B": "10",
                            "C": "200",
                            "D": "500"
                        },
                        "correct_answer": ["A"]
                    }
                    , {
                        "question_number": 70,
                        "question": "以太坊之外部帳戶的公鑰長度為幾位？(以16進制表示)",
                        "options": {
                            "A": "40",
                            "B": "32",
                            "C": "60",
                            "D": "64"
                        },
                        "correct_answer": ["B"]
                    }
                    , {
                        "question_number": 71,
                        "question": "Solidity語言中，可變長位元組陣列包含哪兩種",
                        "options": {
                            "A": "enum",
                            "B": "bytes",
                            "C": "struct",
                            "D": "string"
                        },
                        "correct_answer": ["B","D"]
                    }
                    , {
                        "question_number": 72,
                        "question": "有一solidity程式碼片段如右， struct Member{ string mbrName; uint mbrAge; } mapping(uint => Member) public mbrHash; ，針對此一程式片段請問下列那些選項是正確的？(多選題)",
                        "options": {
                            "A": "若是 uint id = 3; string name = 'John'; uint age = 24; 則可以建構 mbrHash[id] = Member({mbrName:name, mbrAge:age});",
                            "B": "mbrHash如同是資料庫中的一張資料表",
                            "C": "在solidity智能合約中，為了模擬一資料表，通常結構型別會與映射型別一起搭配使用",
                            "D": "mbrHash是映射型別變數"
                        },
                        "correct_answer": ["A", "B","C","D"]
                    }
                    , {
                        "question_number": 73,
                        "question": "下列有關陣列型別的敘述，何者'有誤'？",
                        "options": {
                            "A": "對於 storage 陣列而言，它的元素型別可以是任意型別，包括其它陣列、mapping 型別或結構型別(struct type)",
                            "B": "對於 storage 陣列而言，它的元素型別可以是任意型別，包括其它陣列、mapping 型別或結構型別(struct type)",
                            "C": "陣列可混合宣告成固定與不固定長度",
                            "D": "length 成員修改陣列大小的方式只適用於 storage 變數"
                        },
                        "correct_answer": ["B"]
                    }
                    , {
                        "question_number": 74,
                        "question": "下列有關Solidity的敘述，何者有'有誤'？",
                        "options": {
                            "A": "條件陳述式的大括弧｛｝在單一語句前後是可以省略",
                            "B": "Solidity 允許多重繼承",
                            "C": "if (1) { ... }在 Solidity 中是合法的",
                            "D": "A"
                        },
                        "correct_answer": ["C"]
                    }
                    



                    // Add more questions as needed
                ]);

                //// random shuffle questions ////

                function shuffleArray(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                    }
                }

                function randomizeQuiz(quizRef) {
                    const quiz = quizRef.value;

                    // Shuffle the entire quiz
                    shuffleArray(quiz);

                    quiz.forEach((question, index) => {
                        // Update the question number
                        question.question_number = index + 1;

                        // Store the correct option values before shuffling
                        const correctOptionValues = question.correct_answer.map(answer => question.options[answer]);

                        // Extract options values and shuffle them
                        const optionsValues = Object.values(question.options);
                        shuffleArray(optionsValues);

                        // Assign shuffled values back to the keys
                        Object.keys(question.options).forEach((key, idx) => {
                            question.options[key] = optionsValues[idx];
                        });

                        // Update correct answer keys based on shuffled options
                        question.correct_answer = correctOptionValues.map(value => {
                            return Object.keys(question.options).find(key => question.options[key] === value);
                        });
                    });
                }




                randomizeQuiz(default_questions);
                console.log(default_questions);
                // Now, default_questions is already randomized
                let questions = default_questions;
                ////
                const currentQuestionIndex = ref(0);
                const currentQuestion = ref(
                    questions.value[currentQuestionIndex.value]
                );
                // const selectedOption = ref("");
                const score = ref(0);
                const showResult = ref(false);
                const isCorrect = ref(false);
                const wrongAnswers = ref([]);

                function submitAnswer() {
                    showResult.value = true;
                    const correctOptions = currentQuestion.value.correct_answer;

                    const isCorrectAnswer = correctOptions.every(option => selectedOptions.value.includes(option)) &&
                        selectedOptions.value.every(option => correctOptions.includes(option));

                    if (isCorrectAnswer) {
                        isCorrect.value = true;
                        score.value++;
                    } else {
                        isCorrect.value = false;
                        // Check if the current question is already in the wrongAnswers array
                        const alreadyExists = wrongAnswers.value.some(wrongAnswer =>
                            wrongAnswer.question_number === currentQuestion.value.question_number
                        );

                        if (!alreadyExists) {
                            wrongAnswers.value.push({
                                ...currentQuestion.value,
                                selected_answer: selectedOptions.value.join(", "),
                            });
                        }
                    }

                    setTimeout(() => {
                        nextQuestion();
                        selectedOptions.value = []; // Ensure selected options are reset
                    }, 1000);
                }


                function nextQuestion() {
                    if (currentQuestionIndex.value < questions.value.length - 1) {
                        currentQuestionIndex.value++;
                        currentQuestion.value = questions.value[currentQuestionIndex.value];
                        showResult.value = false;
                        isCorrect.value = false;
                    } else {
                        currentQuestion.value = null;
                    }

                }

                function goBack() {
                    if (currentQuestionIndex.value > 0) {
                        currentQuestionIndex.value--;
                        currentQuestion.value =
                            questions.value[currentQuestionIndex.value];
                        // selectedOption.value = "";
                        showResult.value = false;
                        isCorrect.value = false;
                    }
                }

                function jumpToResult() {
                    currentQuestion.value = null;
                }

                function restartExam() {
                    selectedOptions.value = []; // Add this line

                    // Reshuffle the questions
                    randomizeQuiz(questions);

                    // Reset the quiz state
                    currentQuestionIndex.value = 0;
                    currentQuestion.value = questions.value[currentQuestionIndex.value];
                    // selectedOption.value = "";
                    score.value = 0;
                    showResult.value = false;
                    isCorrect.value = false;
                    wrongAnswers.value = [];
                }



                return {
                    questions,
                    currentQuestion,
                    selectedOptions,
                    submitAnswer,
                    goBack,
                    jumpToResult,
                    score,
                    showResult,
                    isCorrect,
                    wrongAnswers,
                    restartExam,
                };
            },
        }).mount("#app");
    </script>
</body>

</html>